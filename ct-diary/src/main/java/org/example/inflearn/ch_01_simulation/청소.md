# 청소
출처 : [인프런 - 자바 it 대기업 유제] 
Level : 2

## 풀이 날짜
- 2026.02.03 X

## 나의 풀이
```java
class Solution {
  // 보드는 정사각형 board.legnth 길이
  // 첫 방향: R
  // 격자 1개는 1초
  // 1을 만나거나 보드 밖으로 나갈경우 90회전
  // R -> D, D -> L, L -> U, U -> R
  // k초 후에 멈춘 후 로봇의 위치 반환
  public int[] solution(int[][] board, int k){

    // 로봇의 현재 위치
    int n = board.length;
    int[] curLocation = new int[]{0, 0};

    // 이동 오프셋
    HashMap<Character, int[]> offset = new HashMap<>();
    offset.put('R', new int[]{0, 1});
    offset.put('L', new int[]{0, -1});
    offset.put('D', new int[]{1, 0});
    offset.put('U', new int[]{-1, 0});

    char direction = 'R';
    for(int i = 0; i< k; i++){
      int x = curLocation[0];
      int y = curLocation[1];
      int plusX = x + offset.get(direction)[0];
      int plusY = y + offset.get(direction)[1];

      // 방향전환에만 1초 사용
      if(plusX < 0 || plusX >= n || plusY < 0 || plusY >= n ||  board[plusX][plusY] == 1){
        /**
         char[] dirs = {'R', 'D', 'L', 'U'};
         int d = 0; // 0: R, 1: D, 2: L, 3: U
         d = (d + 1) % 4;
         direction = dirs[d];
         */
        if (direction == 'R') direction = 'D';
        else if (direction == 'D') direction = 'L';
        else if (direction == 'L') direction = 'U';
        else direction = 'R';
      }else{
        curLocation[0] = plusX;
        curLocation[1] = plusY;
      }

    }

    return curLocation;
  }
```

## 더 좋은 풀이
```java
class Solution {
    public int[] solution(int[][] board, int k) {
        int n = board.length;

        int x = 0, y = 0; // 시작 위치 (0,0)
        char dir = 'R';  // 초기 방향

        // R, D, L, U 순서
        char[] dirs = {'R', 'D', 'L', 'U'};
        int[][] move = {{0,1}, {1,0}, {0,-1}, {-1,0}};
        int d = 0; // R 인덱스

        for (int i = 0; i < k; i++) {
            int nx = x + move[d][0];
            int ny = y + move[d][1];

            // 벽이거나 장애물(1)이면 방향만 회전
            if (nx < 0 || nx >= n || ny < 0 || ny >= n || board[nx][ny] == 1) {
                d = (d + 1) % 4;
            } else {
                x = nx;
                y = ny;
            }
        }

        return new int[]{x, y};
    } 
```

## 기술 회고
1. HashSet을 쓰지 않고도 이차원배열로 표현하는게 훨씬 깔끔함 
```java
  char[] dirs = {'R', 'D', 'L', 'U'};
  int[][] move = {{0,1}, {1,0}, {0,-1}, {-1,0}};
```

2. 회전은 아래의 방식으로 구현이 가능함
```java 
  2. d = (d + 1) % 4;
```

3. 범위 조심할것
```java
  if (nx < 0 || nx >= n || ny < 0 || ny >= n || board[nx][ny] == 1) {
```

## 회고
