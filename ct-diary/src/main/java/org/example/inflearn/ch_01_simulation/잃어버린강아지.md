# 청소
출처 : [인프런 - 자바 it 대기업 유제]
Level : 2

## 풀이 날짜
- 2026.02.03 []

## 나의 풀이
```java
import java.util.*;
class Solution {
  public int solution(int[][] board){
    // 먼저 강아지와 현수의 위치를 찾아야함
    int hx = 0;
    int hy = 0;
    int dx = 0;
    int dy = 0;
    for(int i = 0 ; i < 10; i++){
      for(int j = 0 ; j < 10; j++){
        if(board[i][j] == 2){
          hx = i;
          hy = j;
        }else if(board[i][j] == 3){
          dx = i;
          dy = j;
        }
      }
    }

    char[] di = new char[]{'u','r','d','l'};
    int[][] offset = new int[4][2];
    offest[0] = new int[]{1, 0};
    offest[1] = new int[]{0, 1};
    offest[2] = new int[]{-1, 0};
    offest[3] = new int[]{-1, 0};

    // 방향         
    int hd = 0;
    int dd = 0;

    count = 0;
    for(int i = 0 ; i < 10; i++){
      for(int j = 0 ; j < 10; j++){
        count++;
        int nhx = hx + offset[hd][1];
        int nhy = hy + offset[hd][0];
        int ndx = dx + offset[dd][1];
        int ndy = dy + offset[dd][0];

        if(board[nhx][nhy] == 1 || nhx < 0 || nhx => 10 || nhy < 0 || nhy => 10){
          // 방향전환                 
          hd = (hd + 1) % 4;
        }else{
          hx = nhx;
          hy = nhy;
        }


        if(board[ndx][ndy] == 1 || ndx < 0 || ndx => 10 || ndy < 0 || ndy => 10){
          // 방향전환
          dd = (dd + 1) % 4;
        }else{
          dx = ndx;
          dy = ndy;
        }

        // 서로만남             
        if(hx == dx && hy == dy) return count;
      }
    }

    return 0;
  }

  public static void main(String[] args){
    Solution T = new Solution();
    int[][] arr1 = {{0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
      {0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
      {0, 0, 0, 1, 0, 0, 0, 1, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 1, 0, 0, 0, 2, 0, 0},
      {1, 0, 0, 0, 0, 0, 1, 0, 0, 0},
      {0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 3, 0, 0, 0, 1},
      {0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
      {0, 1, 0, 1, 0, 0, 0, 0, 0, 0}};
    System.out.println(T.solution(arr1));
    int[][] arr2 = {{1, 0, 0, 0, 1, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 1, 0, 0, 0},
      {0, 0, 1, 1, 0, 0, 0, 1, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 1, 0, 1, 0, 0, 0, 0},
      {1, 0, 0, 0, 0, 0, 1, 0, 1, 0},
      {0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
      {0, 0, 1, 0, 0, 0, 0, 0, 2, 1},
      {0, 0, 0, 1, 0, 1, 0, 0, 0, 1},
      {0, 1, 0, 1, 0, 0, 0, 0, 0, 3}};
    System.out.println(T.solution(arr2));
  }
}
```

## 답안
```java
import java.util.*;

class Solution {
    public int solution(int[][] board){
        // 먼저 강아지와 현수의 위치를 찾아야함
        int humanRow = 0;
        int humanCol = 0;
        int dogRow = 0;
        int dogCol = 0;

        for(int row = 0 ; row < 10; row++){
            for(int col = 0 ; col < 10; col++){
                if(board[row][col] == 2){
                    humanRow = row;       
                    humanCol = col;
                } else if(board[row][col] == 3){ 
                    dogRow = row;       
                    dogCol = col;
                }
            }   
        }

        // 방향 정의 (row 변화, col 변화)
        int[][] offset = new int[4][2];
        offset[0] = new int[]{-1, 0}; // 위
        offset[1] = new int[]{0, 1};  // 오른쪽
        offset[2] = new int[]{1, 0};  // 아래
        offset[3] = new int[]{0, -1}; // 왼쪽

        // 방향 인덱스
        int humanDir = 0;
        int dogDir = 0;

        int count = 0;

        // 10000번 반복       
        for(int i = 0 ; i < 10000; i++){
            count++;

            // 현수 이동
            int nextHumanRow = humanRow + offset[humanDir][0];
            int nextHumanCol = humanCol + offset[humanDir][1];

            if(nextHumanRow < 0 || nextHumanRow >= 10 || 
               nextHumanCol < 0 || nextHumanCol >= 10 || 
               board[nextHumanRow][nextHumanCol] == 1){
                // 방향 전환
                humanDir = (humanDir + 1) % 4;
            } else {
                humanRow = nextHumanRow;
                humanCol = nextHumanCol;
            }

            // 강아지 이동
            int nextDogRow = dogRow + offset[dogDir][0];
            int nextDogCol = dogCol + offset[dogDir][1];

            if(nextDogRow < 0 || nextDogRow >= 10 || 
               nextDogCol < 0 || nextDogCol >= 10 || 
               board[nextDogRow][nextDogCol] == 1){
                // 방향 전환
                dogDir = (dogDir + 1) % 4;
            } else {
                dogRow = nextDogRow;
                dogCol = nextDogCol;
            }

            // 서로 만남
            if(humanRow == dogRow && humanCol == dogCol){
                return count;
            }
        }

        return 0;	
    }

    public static void main(String[] args){
        Solution T = new Solution();
        int[][] arr1 = {
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
            {0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
            {0, 0, 0, 1, 0, 0, 0, 1, 0, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            {0, 0, 0, 1, 0, 0, 0, 2, 0, 0}, 
            {1, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
            {0, 0, 0, 0, 0, 3, 0, 0, 0, 1}, 
            {0, 0, 0, 1, 0, 1, 0, 0, 0, 0}, 
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0}
        }; 
        System.out.println(T.solution(arr1));

        int[][] arr2 = {
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0}, 
            {0, 0, 0, 0, 0, 0, 1, 0, 0, 0}, 
            {0, 0, 1, 1, 0, 0, 0, 1, 0, 0}, 
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
            {0, 0, 0, 1, 0, 1, 0, 0, 0, 0}, 
            {1, 0, 0, 0, 0, 0, 1, 0, 1, 0}, 
            {0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, 
            {0, 0, 1, 0, 0, 0, 0, 0, 2, 1}, 
            {0, 0, 0, 1, 0, 1, 0, 0, 0, 1}, 
            {0, 1, 0, 1, 0, 0, 0, 0, 0, 3}
        }; 
        System.out.println(T.solution(arr2));
    }
}
```

## 기술회고
1. 완전 탐색 문제가 아니니 반복문 2개 사용하는것이 아닌 반복문 한개로 10000개의 범위로 하면 되었음
2. 수학적 좌표랑 2차원 배열의 좌표는 서로 다르니 헷갈려서는 안됨
수학적 좌표: (좌우, 위아래)
2차원 배열: (위아래, 좌우) = new int[행][열] = new int[row][col];
```java
int[][] offset = new int[4][2];
offset[0] = new int[]{-1, 0}; // 위
offset[1] = new int[]{0, 1};  // 오른쪽
offset[2] = new int[]{1, 0};  // 아래
offset[3] = new int[]{0, -1}; // 왼쪽
```